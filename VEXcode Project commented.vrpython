{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\nfrom vexcode_vr import *\n\n\n#8x8 2d array, 0 marks unvisited, 1 marks visited and 2 marks target square\nmaze = [[0 for _ in range(8)] for _ in range(8)] \npath = []\nwalls = {} #dictionary to map each cell to its wall directions\nstartPosition = None\n\ndef convertToGrid(coords):\n    \"\"\"\n    Convert maze coordinates from millimeters to grid cell coordinates\n    so it can be printed to the console easier.\n    Takes in a tuple of x and y coordinates in MM\n    Returns a tuple of row and column grid coordinates from 0 to 7\n    \"\"\"\n    row = int((coords[1] + 1000) / 250)\n    col = int((coords[0] + 1000) / 250)\n    return (row, col)\n\n\ndef mapMaze():\n    \"\"\"\n    Maps the entire maze using Depth-first search with backtracking and path pruning\n    at the same time.\n    Appends the unoptimized path to the path global variable.\n    marks the visited cells as 1 in the global maze 2d array.\n\n    \"\"\"\n    global startPosition\n    stack = [] #stack for backtracking\n    endReached = False #when this is True, no longer append to path\n    startPosition = convertToGrid((location.position(X, MM), location.position(Y, MM)))\n    while True:\n        wait(5, MSEC)\n        coord = (location.position(X, MM), location.position(Y, MM))\n        converted = convertToGrid(coord)\n        #append this cell to the path only until end is reached\n        if not endReached:\n            path.append(converted)\n        row, col = converted[0], converted[1]\n        maze[row][col] = 1 #mark cell as visited\n\n        if down_eye.detect(RED):\n            maze[row][col] = 2 #mark as end square\n            endReached = True\n        #check the next univisted square\n        nextSquare = find_unvisited(row, col)\n        if nextSquare:\n            #append current position to the stack and move robot to the next unvisited cell.\n            stack.append((row, col))\n            moveToCell(nextSquare)\n        elif len(stack) > 0:\n            #backtrack to the previous square, since there are no unvisited adjacent cells.\n            prevSquare = stack.pop()\n            moveToCell(prevSquare)\n        else:\n            break\n        \n\n\n\ndef find_unvisited(row, col):\n    \"\"\"\n    Find the next unvisited neighbouring cell and detect walls\n    Takes row and col of the current position\n    Returns a tuple of row and col of the unvisited neighbor\n    \"\"\"\n    #coordinate increment based on the direction\n    direction = {\n        0: (1, 0),\n        90: (0, 1),\n        180: (-1, 0),\n        270: (0, -1)\n    }\n    #initialise walls for this cell if not already done\n    if (row, col) not in walls:\n        walls[(row, col)] = set()\n    #check all directions, starting from North\n    for angle in [0, 90, 180, 270]:\n        r, c = direction[angle]\n        newR, newC = row + r ,col + c\n\n        #check boundaries\n        if 0 <= newR < 8 and 0 <= newC < 8:\n            drivetrain.turn_to_heading(angle, DEGREES)\n            #check walls\n            if front_distance.get_distance(MM) <= 250:\n                walls[(row, col)].add(angle)\n            else:\n                #check if visited\n                if maze[newR][newC] == 0:\n                    return (newR, newC)\n        else:\n            #out of bounds also counts as a wall\n            walls[(row, col)].add(angle)\n    return None\n\ndef moveToCell(coords):\n    \"\"\"\n    Move the robot to an adjacent cell\n    Takes a tuple containing the row and column of the target cell.\n    \"\"\"\n    cRow, cCol = convertToGrid((location.position(X, MM), location.position(Y, MM)))\n    targetRow = coords[0]\n    targetCol = coords[1]\n    #determine which direction to face based on the target square relative to current position\n    if targetRow > cRow:\n        angle = 0\n    elif targetRow < cRow:\n        angle = 180\n    elif targetCol > cCol:\n        angle = 90\n    elif targetCol < cCol:\n        angle = 270\n    else:\n        return\n\n    drivetrain.turn_to_heading(angle, DEGREES)\n    drivetrain.drive_for(FORWARD, 250, MM)\n\n\ndef optimizePath():\n    \"\"\"\n    Remove dead ends from the path to create the single optimal path\n\n    when a cell is seen for the first time, add it to the stack and the set\n    when it is seen again in the set, pop all cells back to the first time it was seen.\n\n    Returns a list of coordinates representing the optimal path.\n    \"\"\"\n    stack = []\n    #we use a set here for O(1) lookup time, rather than having to iterate through \n    #the stack everytime\n    seen = set() \n    for coord in path:\n        if coord not in seen:\n            stack.append(coord)\n            seen.add(coord)\n        elif coord in seen:\n            #cell has been revisited, remove the dead end by popping back to first instance\n            while stack and stack[-1] != coord:\n                seen.remove(stack.pop())\n    return stack\n\ndef walkOptimalPath():\n    \"\"\"\n    Walk the optimal path, paving the path with a green pen.\n    \"\"\"\n    optimizedPath = optimizePath()\n    pen.move(DOWN)\n    pen.set_pen_color(GREEN)\n    for i in range(1, len(optimizedPath)):\n        moveToCell(optimizedPath[i])\n\n\ndef printMaze():\n    \"\"\"\n    prints an ASCII-style maze to the console\n    \"\"\"\n    brain.print(\"\\n Maze \\n\")\n\n    #Python arrays start from 0 and go down to 7\n    #But the maze has 0 at the bottom and 7 at the top.\n    #So iterate backwards.\n    for row in range(7, -1, -1):\n        #print the top border for horizontal walls\n        topLine = \"\"\n        for col in range(8):\n            topLine += \"+\"\n            #check if there's a wall north of the cell\n            if (row, col) in walls and 0 in walls[(row, col)]:\n                topLine += \"---\"\n            else:\n                topLine += \"   \"\n        topLine += \"+\"\n        brain.print(topLine + \"\\n\")\n\n        cellLine = \"\"\n        for col in range(8):\n            if (row, col) in walls and 270 in walls[(row, col)]:\n                cellLine += \"|\"\n            else:\n                cellLine += \" \"\n        \n            if startPosition and (row, col) == startPosition:\n                cellLine += \" S \"\n            elif maze[row][col] == 2:\n                cellLine += \" E \"\n            elif maze[row][col] == 1:\n                cellLine += \"   \"\n            else:\n                cellLine += \"   \"\n\n        if (row, 7) in walls and 90 in walls[(row, 7)]:\n            cellLine += \"|\"\n        else:\n            cellLine += \" \"\n        brain.print(cellLine + \"\\n\")\n\n    bottomLine = \"\"\n    for col in range(8):\n        bottomLine += \"+\"\n        if (0, col) in walls and 180 in walls[(0, col)]:\n            bottomLine += \"---\"\n        else:\n            bottomLine += \"   \"\n    bottomLine += \"+\"\n    brain.print(bottomLine + \"\\n\")\n\ndef when_started1():\n    #set the robot to max speed for a faster runtime\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    mapMaze()\n    printMaze()\n    optimizePath()\n\n    brain.print(\"Optimized path: \\n\")\n    brain.print(path)\n\n    walkOptimalPath()\n\n\n\n\n\nvr_thread(when_started1)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}